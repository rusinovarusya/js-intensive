# 1. Подробно прочитать про метод запроса OPTIONS - и кратко его описать, когда вызывается, где используется, что передает и принимает.

Метод OPTIONS запрашивает информацию о параметрах связи, доступных для целевого ресурса, или на исходном сервере, либо на промежуточном посреднике. Этот метод позволяет клиенту определять параметры и/или требования, связанные с ресурсом, или возможности сервера, не подразумевая действия с ресурсом.

Запрос содержит URL-адрес или * (сервер). Запросу HTTP OPTIONS не запрещено иметь тело сообщения. Однако на данный момент спецификация не определяет его формат или использование.

Ответ будет содержать поле HTTP заголовка Allow, в котором перечислены поддерживаемые функции. Ответы на метод OPTIONS не кэшируются.

# 2. Прочитать и описать ключевые особенности "HTTP" Версии 3.0

Ключевой особенностью HTTP/3 является использование мультиплексированного транспортного протокола QUIC, построенного на UDP, вместо комбинации TCP и TLS. QUIC запускает несколько независимых потоков, поэтому в случае потери пакетов повторная передача блокирует только поток с ошибкой. Данные зашифрованы, открытым остается идентификатор соединения CID, который позволяет осуществить миграцию подключений. HTTP/3 также использует новый механизм сжатия заголовков QPACK – модификация HPACK, позволяет заголовкам поступать не по порядку и в разных потоках.

# 3. Прочитать про способы отмены запроса, включая объект "AbortController"

AbortController - встроенный объект для отмены асинхронных задач. Экземпляр AbortController имеет свойство AbortController.signal (только для чтения) – возвращает экземпляр AbortSignal, который может быть использован для коммуникаций или останова DOM запросов, и метод AbortController.abort() – прерывает DOM запрос до момента его завершения.

# 3. Написать по 2 примера создания примитивных значений (если есть несколько способов - использовать) (string, number, boolean, null, undefined, symbol, bigInt)

`const str1 = "The first string";`
``const str2 = `String number ${1 + 1}`;``
`const num1 = 1;`
`const num2 = Number(1 + "1" - 9) + "1" * 1 + +"-1";`
`const boolean1 = true;`
`const boolean2 = !!0;`
`const null1 = null;`
`const null2 = null;`
`const undefined1 = undefined;`
`let undefined2;`
`const symbol1 = Symbol();`
`const symbol2 = Symbol(str1);`
`const bigInt1 = 1n;`
`const bigInt2 = BigInt(2);`

# 4. Почему, если обратиться к переменным созданным через let, const до их объявления - мы получаем *ReferenceError*?

Область видимости переменных, объявленных с помощью **let** и **const** - блочная. Всплытие с мертвой зоной - temporal dead zone (TDZ). Поэтому получается, что обращаются к переменным до того, как они будут созданы.

# 5. Решить: 

`const res = "B" + "a" + (1 - "hello");`
`console.log(res); // ошибка или NaN; при вычислении (1 - "hello") получим NaN, так как эту строку невозможно преобразовать в число, в то время как "B" + "a" равно "Ba"`

`const res2 = (true && 3) + "d";`
`console.log(res2); // "3d"; выражение в скобках - true, но оператор вернет последний операнд в исходном типе данных, то есть 3, при сложении со строкой получена строка`

`const res3 = Boolean(true && 3) + "d";`
`console.log(res3); // "trued"; выражение в скобках - true, при сложении со строкой получена строка`
